<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galaxy Cinematic Experience</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;cursor:none}
  canvas{display:block;width:100vw;height:100vh}
  body::before {
    content: "";
    position: fixed; inset:0;
    background: radial-gradient(circle, rgba(100,150,255,0.9) 0px, transparent 2px) repeat;
    background-size: 40px 40px; opacity:0.25; z-index:-1;
  }
  body::after {
    content: "";
    position: fixed; inset:0;
    background: radial-gradient(circle, rgba(100,150,255,0.6) 0px, transparent 3px) repeat;
    background-size: 80px 80px; opacity:0.15; z-index:-1;
  }
  .cinematic-overlay{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:100;background:linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 20%, transparent 80%, rgba(0,0,0,0.8) 100%);}
  .shot-title{display:none;} /* Hide shot title */
  .shot-counter{position:fixed;top:20px;right:20px;color:rgba(255,255,255,0.6);font-family:Arial,sans-serif;font-size:16px;}
  .controls{position:fixed;bottom:20px;width:100%;text-align:center;color:rgba(255,255,255,0.7);font-family:Arial,sans-serif;font-size:14px;opacity:0.3;transition:opacity 0.5s;}
  .controls:hover{opacity:1;}
  .fullscreen-btn {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 32px;
    height: 32px;
    cursor: pointer;
    opacity: 0.5;
    transition: opacity 0.3s;
    z-index: 1000;
  }
  .fullscreen-btn:hover {
    opacity: 1;
  }
  .fullscreen-btn svg {
    width: 100%;
    height: 100%;
    fill: rgba(255,255,255,0.8);
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div class="cinematic-overlay"></div>
<div class="shot-title" id="shotTitle"></div>
<div class="shot-counter" id="shotCounter"></div>
<div class="controls">Click to pause/resume | Press â†’ to skip shot | Press R to restart sequence</div>

<!-- Fullscreen button -->
<div class="fullscreen-btn" id="fullscreenBtn">
  <svg viewBox="0 0 24 24">
    <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
  </svg>
</div>

<script>
(() => {
  const params = {spinSpeed:0.00018, starCount:5400, arms:5, cameraDistanceFactor:1.6, armTightness:4.5, coreHeightFactor:0.1, bgStarCount:900};

  // ---------- Cinematic shots ----------
  const cinematicShots = [
    { name:"Dive Through Core", duration:10000, zoom:[2.5,0.05,2.5], rotX:[-0.4,0,0.4], rotY:[0.5,1.5,2.5], coreDive:true },
    { name:"Slow Core Dive", duration:15000, zoom:[3.0,0.02,3.0], rotX:[-0.3,0,0.3], rotY:[0.8,1.8,2.8], coreDive:true, slowDive:true },
    { name:"Wide Orbit", duration:8000, zoom:[2.2,1.5], rotX:[-0.8,-0.6], rotY:[0,1] },
    { name:"Zoom Through Spiral", duration:8000, zoom:[2.2,0.8], rotX:[-0.6,-0.4], rotY:[0,1.5] },
    { name:"God's-Eye Spin", duration:8000, zoom:[1.5,1.5], rotX:[-1.57,-1.57], rotY:[0,2] },
    { name:"Tilted Drift", duration:8000, zoom:[1.3,1.4], rotX:[-1.0,-0.8], rotY:[0,1.2] },
    { name:"Core Push-In", duration:8000, zoom:[1.3,0.4], rotX:[-0.8,-0.4], rotY:[0,0.8] },
    { name:"Time-Lapse Rotation", duration:8000, zoom:[1.2,1.2], rotX:[-0.7,-0.7], rotY:[0,4], timeLapse:3 },
    { name:"Edge Perspective", duration:8000, zoom:[1.1,1.2], rotX:[-0.2,-0.2], rotY:[0,1.5] },
    { name:"Track Spiral Arm", duration:8000, zoom:[0.9,0.9], rotX:[-0.6,-0.5], rotY:[0,1.2], tracking:true },
    { name:"Rotate With Galaxy", duration:8000, zoom:[1.4,1.4], rotX:[-0.8,-0.8], rotY:[0,Math.PI] },
    { name:"Pullback Cosmic Scale", duration:8000, zoom:[0.6,2.5], rotX:[-0.9,-0.7], rotY:[0,0.5] }
  ];

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const shotCounter = document.getElementById('shotCounter');
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let CAMERA_DISTANCE = Math.max(innerWidth,innerHeight)*params.cameraDistanceFactor;
  let stars = [];
  const camera = {distance:CAMERA_DISTANCE, rotX:-1.2, rotY:2.8, trackingX:0, trackingY:0};
  let currentShot=0, shotStartTime=0, timeLapseFactor=1, isPaused=false;

  // Fullscreen functionality
  fullscreenBtn.addEventListener('click', toggleFullscreen);
  
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log(`Error attempting to enable fullscreen: ${err.message}`);
      });
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  }

  function resize(){
    DPR=Math.max(1,window.devicePixelRatio||1);
    canvas.width=innerWidth*DPR;
    canvas.height=innerHeight*DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
    CAMERA_DISTANCE=Math.max(innerWidth,innerHeight)*params.cameraDistanceFactor;
    regenerate();
  }
  addEventListener('resize',resize);
  resize();

  function regenerate(){
    stars=[];
    const R=Math.hypot(innerWidth/2,innerHeight/2);
    for(let i=0;i<params.starCount;i++){
      const arm=i%params.arms;
      const armAngle=(arm/params.arms)*Math.PI*2;
      const t=Math.random()*R*0.85;
      const armOffset=-(t/R)*params.armTightness*Math.PI;
      const theta=armAngle+armOffset+(Math.random()-0.5)*0.15;
      const spread=Math.random()*14*(1-t/R);
      const baseX=Math.cos(theta)*t+(Math.random()-0.5)*spread;
      const baseY=Math.sin(theta)*t+(Math.random()-0.5)*spread*0.6;
      const baseZ=(Math.random()-0.5)*Math.max(60,innerWidth*0.08)*params.coreHeightFactor;
      const size=Math.random()<0.65?Math.max(0.6,(1-t/R)*2.8):Math.max(0.3,(1-t/R)*1.5);
      let color;
      if(Math.random()<0.65){ const r=120+Math.floor(Math.random()*60), g=120+Math.floor(Math.random()*60), b=180+Math.floor(Math.random()*40); color=`rgba(${r},${g},${b},${(0.6+Math.random()*0.4).toFixed(3)})`; }
      else { const r=200+Math.floor(Math.random()*55), g=200+Math.floor(Math.random()*55), b=230+Math.floor(Math.random()*25); color=`rgba(${r},${g},${b},${(0.35+Math.random()*0.45).toFixed(3)})`; }
      stars.push({angle:theta,radius:t,x:baseX,y:baseY,z:baseZ,size,color,arm,twinkle:false});
    }
    for(let i=0;i<params.bgStarCount;i++){
      const radius=Math.random()*R*1.3, angle=Math.random()*Math.PI*2, z=(Math.random()-0.5)*Math.max(120,innerWidth*0.15), size=0.4+Math.random()*0.8;
      const palette=[[220,220,255],[255,255,255],[255,245,200],[200,220,255]]; const c=palette[Math.floor(Math.random()*palette.length)];
      stars.push({angle,radius,x:0,y:0,z,size,color:c,baseAlpha:0.45+Math.random()*0.45,twinkle:true,twinklePhase:Math.random()*Math.PI*2,twinkleSpeed:0.001+Math.random()*0.002});
    }
  }

  function ease(t){return t<0.5?2*t*t:-1+(4-2*t)*t;}
  function showShot(index){
    currentShot=index%cinematicShots.length;
    shotStartTime=performance.now();
    timeLapseFactor=cinematicShots[currentShot].timeLapse||1;
    shotCounter.textContent=`${currentShot+1}/${cinematicShots.length}`;
  }
  function nextShot(){ showShot(currentShot+1); }
  function restartSequence(){ showShot(0); }

  canvas.addEventListener('click',()=>{ isPaused=!isPaused; if(!isPaused) last=performance.now(); requestAnimationFrame(draw); });
  document.addEventListener('keydown',e=>{ 
    if(e.key==='ArrowRight') nextShot(); 
    else if(e.key==='r'||e.key==='R') restartSequence();
    else if(e.key==='f'||e.key==='F') toggleFullscreen();
  });

  showShot(0);

  let last=performance.now();
  function draw(now){
    if(isPaused) return;
    const dt=now-last; last=now;
    const W=innerWidth,H=innerHeight;
    const shotElapsed=now-shotStartTime;
    const shot=cinematicShots[currentShot];
    let progress=Math.min(1,shotElapsed/shot.duration);
    
    // Use different easing for core dive to create more dynamic movement
    let t;
    if (shot.coreDive) {
      if (shot.slowDive) {
        // Special easing for slow dive - more gradual approach and exit
        if (progress < 0.2) {
          t = ease(progress / 0.2) * 0.2;
        } else if (progress < 0.5) {
          t = 0.2 + (progress - 0.2) / 0.3 * 0.3;
        } else if (progress < 0.8) {
          t = 0.5 + (progress - 0.5) / 0.3 * 0.3;
        } else {
          t = 0.8 + ease((progress - 0.8) / 0.2) * 0.2;
        }
      } else {
        // Standard core dive easing
        if (progress < 0.3) {
          t = ease(progress / 0.3) * 0.3;
        } else if (progress < 0.7) {
          t = 0.3 + (progress - 0.3) / 0.4 * 0.4;
        } else {
          t = 0.7 + ease((progress - 0.7) / 0.3) * 0.3;
        }
      }
    } else {
      t = ease(progress);
    }

    // Camera zoom/rotation - handle multi-segment animations for core dive
    if (shot.coreDive && shot.zoom.length > 2) {
      if (shot.slowDive) {
        // Slow dive has 4 segments for more dramatic effect
        if (progress < 0.2) {
          // First segment: approach from a distance
          const segmentProgress = progress / 0.2;
          camera.distance = ((shot.zoom[1]-shot.zoom[0])*segmentProgress + shot.zoom[0])*Math.max(W,H);
          camera.rotX = ((shot.rotX[1]-shot.rotX[0])*segmentProgress + shot.rotX[0]);
          camera.rotY = ((shot.rotY[1]-shot.rotY[0])*segmentProgress + shot.rotY[0]);
        } else if (progress < 0.5) {
          // Second segment: slow approach to core
          const segmentProgress = (progress - 0.2) / 0.3;
          camera.distance = ((shot.zoom[2]-shot.zoom[1])*segmentProgress + shot.zoom[1])*Math.max(W,H);
          camera.rotX = ((shot.rotX[2]-shot.rotX[1])*segmentProgress + shot.rotX[1]);
          camera.rotY = ((shot.rotY[2]-shot.rotY[1])*segmentProgress + shot.rotY[1]);
        } else if (progress < 0.8) {
          // Third segment: through the core (slowest part)
          const segmentProgress = (progress - 0.5) / 0.3;
          camera.distance = ((shot.zoom[3]-shot.zoom[2])*segmentProgress + shot.zoom[2])*Math.max(W,H);
          camera.rotX = ((shot.rotX[3]-shot.rotX[2])*segmentProgress + shot.rotX[2]);
          camera.rotY = ((shot.rotY[3]-shot.rotY[2])*segmentProgress + shot.rotY[2]);
        } else {
          // Fourth segment: emerging on the other side
          const segmentProgress = (progress - 0.8) / 0.2;
          camera.distance = ((shot.zoom[4]-shot.zoom[3])*segmentProgress + shot.zoom[3])*Math.max(W,H);
          camera.rotX = ((shot.rotX[4]-shot.rotX[3])*segmentProgress + shot.rotX[3]);
          camera.rotY = ((shot.rotY[4]-shot.rotY[3])*segmentProgress + shot.rotY[3]);
        }
      } else {
        // Standard core dive with 3 segments
        if (progress < 0.3) {
          // First segment: approach from tilted side view
          const segmentProgress = progress / 0.3;
          camera.distance = ((shot.zoom[1]-shot.zoom[0])*segmentProgress + shot.zoom[0])*Math.max(W,H);
          camera.rotX = ((shot.rotX[1]-shot.rotX[0])*segmentProgress + shot.rotX[0]);
          camera.rotY = ((shot.rotY[1]-shot.rotY[0])*segmentProgress + shot.rotY[0]);
        } else if (progress < 0.7) {
          // Second segment: through the core
          const segmentProgress = (progress - 0.3) / 0.4;
          camera.distance = ((shot.zoom[2]-shot.zoom[1])*segmentProgress + shot.zoom[1])*Math.max(W,H);
          camera.rotX = ((shot.rotX[2]-shot.rotX[1])*segmentProgress + shot.rotX[1]);
          camera.rotY = ((shot.rotY[2]-shot.rotY[1])*segmentProgress + shot.rotY[1]);
        } else {
          // Third segment: emerging on the other side
          const segmentProgress = (progress - 0.7) / 0.3;
          camera.distance = ((shot.zoom[3]-shot.zoom[2])*segmentProgress + shot.zoom[2])*Math.max(W,H);
          camera.rotX = ((shot.rotX[3]-shot.rotX[2])*segmentProgress + shot.rotX[2]);
          camera.rotY = ((shot.rotY[3]-shot.rotY[2])*segmentProgress + shot.rotY[2]);
        }
      }
    } else {
      // Standard animation for other shots
      camera.distance=((shot.zoom[1]-shot.zoom[0])*t + shot.zoom[0])*Math.max(W,H);
      camera.rotX=(shot.rotX[1]-shot.rotX[0])*t + shot.rotX[0];
      camera.rotY=(shot.rotY[1]-shot.rotY[0])*t + shot.rotY[0];
    }
    
    camera.trackingX=shot.tracking?Math.cos(progress*1.5)*100*progress:0;
    camera.trackingY=shot.tracking?Math.sin(progress*1.5)*50*progress:0;

    ctx.clearRect(0,0,W,H);
    ctx.save(); ctx.translate(W/2+camera.trackingX,H/2+camera.trackingY);
    const cosX=Math.cos(camera.rotX), sinX=Math.sin(camera.rotX), cosY=Math.cos(camera.rotY), sinY=Math.sin(camera.rotY);

    // Draw stars
    for(const s of stars){
      s.angle+=params.spinSpeed*dt*timeLapseFactor*(0.5+(s.radius||0)*0.0005);
      const x=Math.cos(s.angle)*s.radius;
      const y=Math.sin(s.angle)*s.radius;
      let z=s.z||0;
      let rx=cosY*x+sinY*z, rz=-sinY*x+cosY*z;
      let ry=cosX*y-sinX*rz; rz=sinX*y+cosX*rz;
      const denom=Math.max(120,camera.distance+rz);
      const proj=camera.distance/denom;
      const sx=rx*proj, sy=ry*proj;
      const safeSize=Math.abs(s.size||0.5); const screenR=Math.max(0.15,safeSize*Math.max(0.001,proj));
      let fillStyle;
      if(s.twinkle&&Array.isArray(s.color)){
        const tw=0.4+0.6*Math.abs(Math.sin((s.twinklePhase||0)+now*(s.twinkleSpeed||0.001)));
        const alpha=Math.min(1,(s.baseAlpha||0.6)*tw);
        fillStyle=`rgba(${s.color[0]},${s.color[1]},${s.color[2]},${alpha.toFixed(3)})`;
      } else fillStyle=s.color;
      ctx.beginPath(); ctx.fillStyle=fillStyle; ctx.arc(sx,sy,screenR,0,Math.PI*2); ctx.fill();
    }

    // Draw galactic core with enhanced glow effect during dive
    const coreRadius=22;
    let coreGlowFactor = 1;
    
    // Increase core brightness when passing through it
    if (shot.coreDive) {
      if (shot.slowDive && progress > 0.3 && progress < 0.7) {
        // More dramatic glow for slow dive
        const intensity = 1 + 3 * Math.sin(Math.PI * (progress - 0.3) / 0.4);
        coreGlowFactor = Math.max(1, intensity);
      } else if (progress > 0.3 && progress < 0.7) {
        const intensity = 1 + 2 * Math.sin(Math.PI * (progress - 0.3) / 0.4);
        coreGlowFactor = Math.max(1, intensity);
      }
    }
    
    const gradient=ctx.createRadialGradient(0,0,0,0,0,coreRadius*6);
    gradient.addColorStop(0,`rgba(255,255,220,${0.9*coreGlowFactor})`);
    gradient.addColorStop(0.3,`rgba(255,220,180,${0.6*coreGlowFactor})`);
    gradient.addColorStop(1,`rgba(255,200,200,0)`);
    ctx.beginPath(); ctx.fillStyle=gradient; ctx.arc(0,0,coreRadius*6,0,Math.PI*2); ctx.fill();
    
    // Core itself
    ctx.beginPath(); 
    ctx.fillStyle=`rgba(255,255,240,${0.95*coreGlowFactor})`; 
    ctx.arc(0,0,coreRadius,0,Math.PI*2); 
    ctx.fill();

    ctx.restore();

    if(progress>=1){
      ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,0,W,H);
      setTimeout(()=>{ nextShot(); requestAnimationFrame(draw); },300);
      return;
    }

    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
